## 浏览器的事件环

关心我们的异步任务时怎样执行的，定时器 ajax 底层还是基于多线程模型

> 计算机调度任务的基本单位都是以进程单位（进程中包含这线程）

## 浏览器是一个多线程模型

浏览器每一个页卡都是一个进程（整个主界面）

- 渲染进程（执行 js 引擎 执行绘制 ui 线程）
- 网络进程 存储 请求
- 插件
- gpu 进程

渲染进程：（js 线程 ui 渲染进程 互斥，js 主线程是单线程的 单线程阻塞）
为甚 js 不设计成多线程模型，（1 个线程说删掉 dom 元素）（另一个说要追加一个） 页面渲染和 js 也是互斥的（正在执行 js 的时候 可能需要删除 dom，页面就不需要渲染这个节点）

webworker 创建的叫工作线程（计算，不能操作 dom）

## js 特点是单线程异步的（异步任务进行分类， 底层实现肯定基于线程的）

- 宏任务：执行 js 脚本是一个宏任务，ui 渲染 ajax，定时器，事件，MessageChannel，setImmediate 宏任务队列
  “队列只有一个”

- 微任务：promise mutationObserver

> 宏任务队列只有一个（消息队列，宏任务队列）

> 微任务队列 每执行一轮

## node 是啥

- 就是 js 的一个运行时，可以让 js 运行在服务端（js 由什么组成 3 部分 BOM DOM EC，NODE 中不能使用 BOM 和 DOM 只有 EC + 内置的模块 自己写的功能 + 第三方模块）

- node 依旧是“主线程”是单线程的（通常情况下 单线程 好处是如果做的事简单 那么并发量高）

- 类似于 java，php 多线程同步模型（感觉可以一起做多件事） 会浪费很多线程（内存） 可以利用线程池来优化，对于多线程而言 操作同一个资源会有锁的问题（多线程感觉是一起执行 对于单核 cpu 而言） 通过切换时间片达到同时执行 （优点就是：适合 cpu 密集型）

对于 node 而言 就是单线程模型 如果是这种（I/O 密集型 比较适合） 通常情况下 好处是异步非阻塞

异步同步 指的是调用方法的本身（被调用放决定是不是异步） fs.readFile writeFile 异步 api
阻塞非阻塞 指的是调用方法的本身

状态：同步阻塞（稍等我马上回复你） 异步非阻塞（明天我给你消息）

> 处理高并发 nginx 单线程非阻塞处理

---

》 node 一般做中间层 服务端渲染 前端有工具 webpack 服务端接口

## node 的基本用法

## 模板引擎基本概念

nuw Function 在模板引擎中使用是非常多的（）

vue 中的{{}} 模板引擎 `${}` ejs jade underscore handlebar pug nunjuncks...
